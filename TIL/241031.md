#### **강의 외부에서 추가로 알게 된 내용**

-   **비트 연산자는 **AND 연산자(**&)로 짝수 홀수 구분하기**

숫자에 1을 AND 연산하면 홀수와 짝수를 구분할 수 있다.

**짝수**는 이진수로 표현할 때 마지막 비트가 0이다. (2, 4, 6 등)

**홀수**는 이진수로 표현할 때 마지막 비트가 1이다. (1, 3, 5 등)

따라서, 아래의 코드와 같이 x & 1 연산을 사용하여 짝수와 홀수를 구분할 수 있다.

```
x & 1 == 0: 짝수
x & 1 == 1: 홀수
```

 예시 코드는 아래와 같다.

```
x = 5
if x & 1:
    print("홀수입니다.")
else:
    print("짝수입니다.")
# 5는 이진수로 101이므로 5 & 1은 1. 따라서 홀수로 출력된다.
# 4는 이진수로 100이므로 4 & 1은 0. 따라서 짝수로 출력된다.
```

비트 연산자를 사용하면 일반적인 나머지 연산보다 속도가 빠르기 때문에, 짝수와 홀수를 구분하는 데 효율적이다.

-   **프로그래밍 관련 개념들의 포함 관계**

포함 관계 다이어그램은 아래와 같다.

```
모듈
│
├── 패키지
│   ├── 모듈 (하위 모듈)
│   │   ├── 클래스
│   │   │   ├── 속성
│   │   │   ├── 메서드
│   │   │   ├── 클래스 변수
│   │   │   └── 인터페이스 (구현)
│   │   └── 함수
│   └── 인터페이스
│
└── 예외 처리

모듈
│
├── 패키지
│   ├── 모듈 (하위 모듈)
│   │   ├── 추상 클래스
│   │   │   ├── 속성
│   │   │   ├── 추상 메서드
│   │   │   └── 메서드 (구현)
│   │   ├── 클래스 (서브클래스)
│   │   │   ├── 속성
│   │   │   ├── 메서드 (구현)
│   │   └── 함수
│   └── 인터페이스
│
└── 예외 처리
```

**모듈 (Module)**은 관련된 함수, 클래스, 변수 등을 하나의 파일로 묶은 것이다. 파이썬에서 모듈은 .py 확장자를 가진 파일이다. 예) math, itertools, os 등의 내장 모듈. 사용 목적은 코드의 재사용성을 높이고, 프로그램을 조직적으로 관리하기 위해서이다. 모듈은 주로 여러 기능을 제공하는 하나의 파일로서, 파일의 경로를 통해 임포트하여 사용할 수 있다.

**패키지 (Package)**는 여러 모듈을 묶어서 하나의 그룹으로 관리할 수 있는 구조이다. 대규모 프로젝트에서 모듈을 그룹화하여 관리하기 위해 사용한다.

**클래스 (Class)**는 객체를 생성하기 위한 템플릿으로, 객체의 속성과 메서드를 정의한다. 클래스는 속성과 메서드를 통해 상태를 유지하고 동작을 수행한다.

**  
추상 클래스 (Abstract Class)**는 일부 메서드에 대한 구체적인 구현을 제공하지 않고, 서브클래스에서 이 메서드를 구현하도록 강제하는 클래스이다. 이는 인터페이스와 유사하지만, 일반적인 속성과 메서드를 포함할 수 있다.

**속성 (Attribute)**은 객체에 속하는 변수로, 클래스의 인스턴스에 포함된 데이터를 나타낸다. 객체의 상태나 특성을 나타낸다. 예) obj.attribute처럼 객체 obj의 attribute라는 속성. 사용 목적은 객체가 가지고 있는 정보를 저장하고, 해당 객체의 상태를 유지하기 위해서이다. 속성은 클래스의 인스턴스와 관련이 있으며, 객체에 대한 정보를 담고 있는 변수이다.

**메서드 (Method)**는 클래스 내에 정의된 함수로, 클래스의 인스턴스에서 호출할 수 있다. 메서드는 클래스와 밀접한 관계가 있다. 예)  class Dog: def bark(self): print("Woof!")에서 bark는 메서드이다. 사용 목적은 객체의 상태를 변경하거나 객체와 관련된 작업을 수행하기 위해서이다. 메서드는 클래스에 속하는 함수이며, 일반적인 함수와는 다르게 객체의 상태를 조작할 수 있다.

**클래스 변수 (Class Variable)**는 클래스에 속하는 변수로, 모든 인스턴스가 공유하는 속성이다. 인스턴스 변수와는 달리, 모든 인스턴스가 동일한 값을 갖다.

**인터페이스 (Interface)**는 특정 메서드를 정의하지만, 그 메서드의 구체적인 구현을 제공하지 않는 클래스이다. 다른 클래스에서 이 인터페이스를 구현하여 해당 메서드를 정의할 수 있다. 파이썬에서는 인터페이스를 명시적으로 정의하는 방법은 없지만, 추상 클래스를 통해 유사하게 사용할 수 있다.

**함수 (Function)**는 특정 작업을 수행하는 코드 블록으로, 입력값을 받아 결과값을 반환한다. 독립적으로 호출할 수 있다. 예)  def add(a, b): return a + b처럼 정의된 함수. 사용 목적은 코드의 재사용성을 높이고, 특정 작업을 반복적으로 수행하기 위해서이다. 함수는 독립적으로 호출될 수 있는 코드 블록이며, 특정 작업을 수행한다.

**예외 처리 (Exception Handling)**는 프로그램 실행 중 발생할 수 있는 오류를 관리하는 구조이다. 예외 처리는 일반적인 프로그램 흐름과는 별개로 동작하며, 예외 발생 시 특정 작업을 수행하도록 구성할 수 있다.

-   **combinations(iterable, r)**

Python의 itertools 모듈에 포함된 함수로, 주어진 iterable(예: 리스트, 튜플 등)에서 r개의 요소를 선택하여 조합(combination) 을 생성하는 데 사용된다. 조합은 순서가 중요하지 않으며, 중복을 허용하지 않는다. 기본 사용법은 아래의 코드와 같다. **반환값**은 길이가 r인 조합의 튜플로 이루어진 iterator를 반환한다.

```
from itertools import combinations

combinations(iterable, r)
# iterable: 조합을 생성할 원본 데이터 구조 (리스트, 튜플, 문자열 등).
# r: 조합에 포함될 요소의 개수.
```

예시를 살펴보자.

```
# 기본 예시
from itertools import combinations

data = ['A', 'B', 'C']
result = list(combinations(data, 2))
print(result)
# 출력 : 리스트 ['A', 'B', 'C']에서 2개의 요소를 선택한 모든 조합을 생성한다.
[('A', 'B'), ('A', 'C'), ('B', 'C')]

# 숫자 리스트 조합
from itertools import combinations

numbers = [1, 2, 3, 4]
result = list(combinations(numbers, 3))
print(result)
# 출력 : 리스트 [1, 2, 3, 4]에서 3개의 숫자를 선택한 모든 조합을 생성한다.
[(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]

# 문자열 조합
from itertools import combinations

word = 'abc'
result = list(combinations(word, 2))
print(result)
# 출력 : 문자열 'abc'에서 2개의 문자를 선택한 모든 조합을 생성한다.
[('a', 'b'), ('a', 'c'), ('b', 'c')]
```

주의사항에 대해 알아보자. 조합의 순서가 중요하지 않기 때문에, (A, B)와 (B, A)는 같은 조합으로 간주된다. r의 값이 iterable의 길이보다 크면 빈 조합이 반환된다. combinations는 iterator를 반환하므로, 결과를 사용하기 위해서는 list()와 같은 방법으로 변환해야 한다.