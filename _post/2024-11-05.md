---
title: "[GitHub Blog] TIL 29"

writer: ysooj
categories:
- GitHub Blog
tags: [Blog, jekyll, Github, Git, markdown, TIL]

toc: true
toc_sticky: true

date: 2024-11-05
---

### **강의 소제목**

강의 내용

---

### **강의 외부에서 추가로 알게 된 내용**

-   **re.findall() 함수**

**re.findall(r'\\d+', my\_string)**은 Python의 정규 표현식(re 모듈)을 사용해 문자열 my\_string에서 연속된 숫자들을 찾아 리스트로 반환하는 명령이다.

**re.findall() 함수**는 정규 표현식 패턴에 맞는 모든 부분을 찾아 리스트로 반환한다. 만약 찾는 패턴이 없다면 빈 리스트를 반환한다.

여기서 쓰인 정규 표현식 패턴에 대해 알아보자.

-   **r'...'** : 문자열 앞에 r을 붙이면 "raw string"(raw 문자열)으로, 백슬래시 \\를 특수한 문자로 인식하지 않고 그대로 사용하게 한다. 이를 통해 \\d를 "백슬래시와 d"가 아닌 "정규 표현식에서 숫자를 의미하는 \\d"로 인식하게 된다.
-   **\\d** : 숫자(0에서 9 사이의 모든 숫자) 하나를 의미한다.
-   **\+** : +는 앞의 패턴(\\d)이 **하나 이상** 연속되는 부분을 찾게 만든다.

이 re.findall(r'\\d+', my\_string)이 어떻게 동작하는지 예를 통해 살펴보자.

```
# 예시 1
my_string = "aAb1B2cC34oOp"
# 결과
['1', '2', '34']
```

\\d+는 하나 이상의 연속된 숫자 부분을 찾으므로, 이 문자열에서는 "1", "2", 그리고 "34"를 찾아내어 리스트로 반환한다.

```
# 예시 2
my_string = "123abc456def"
# 결과
['123', '456']
```

여기서는 연속된 숫자 덩어리 "123"과 "456"을 찾아내어 리스트로 반환한다.

이 결과 리스트는 숫자로 구성된 문자열들로 이루어져 있다.

-   **itertools 모듈의 permutations 함수**

주어진 iterable(리스트, 문자열 등)에서 가능한 모든 순열을 생성하는 데 사용된다. 이 함수는 조합(combination)과는 달리, 선택한 요소들의 순서도 고려하여 모든 가능한 배열을 생성한다.

주어진 원소들로 만들 수 있는 모든 배열의 나열이다. 예를 들어, 원소가 \['A', 'B', 'C'\]라면 가능한 **순열**은 \['A', 'B', 'C'\], \['A', 'C', 'B'\], \['B', 'A', 'C'\], \['B', 'C', 'A'\], \['C', 'A', 'B'\], \['C', 'B', 'A'\]의 총 6가지다.

사용 방법을 알아보자. 먼저 모듈을 import해와야 한다.

```
from itertools import permutations
```

기본 사용법은 아래와 같다.

```
result = permutations(iterable, r)
# iterable: 순열을 생성할 대상이다.(예: 리스트, 문자열 등)
# r: 선택할 원소의 개수입니다. 이 인자를 생략하면 iterable의 길이만큼의 순열을 생성한다.
```

permutations 함수는 **반환값**으로는 순열을 튜플 형태로 생성하여 반환한다. 이를 리스트로 변환하거나, 필요한 형태로 처리해야 한다.

예시를 통해 다시 살펴보자.

```
# 기본 사용 예시
from itertools import permutations

data = ['A', 'B', 'C']

# 모든 순열 생성
result = list(permutations(data))
print(result)

# 출력
[('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), 
('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]
```

이 예시는 \['A', 'B', 'C'\]의 모든 순열을 생성하여 리스트로 반환한다.

```
# 선택 개수를 지정하는 예시
from itertools import permutations

data = ['A', 'B', 'C']

# 2개를 선택하여 순열 생성
result = list(permutations(data, 2))
print(result)

# 출력
[('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]
```

이 예시는 \['A', 'B', 'C'\]에서 2개를 선택한 순열을 생성합니다. 즉, 원소를 2개만 사용하여 만들 수 있는 모든 배열을 반환한다.

주의할 점은 다음과 같다. 순열의 개수는 원소의 개수에 따라 기하급수적으로 증가한다. 예를 들어, n개의 원소가 있을 때, 순열의 수는 n!n!n! (n factorial)이다. 예를 들어, 4개의 원소가 있으면 4! = 24개의 순열이 존재한다.

메모리 사용량과 성능에 주의해야 하며, 큰 입력에서는 효율적인 방법으로 대체할 수 있는지를 고려해야 한다.

활용 예시는 다음과 같다. 순열은 조합 문제, 일정한 규칙을 따른 다양한 배열을 생성하는 데 유용하게 사용된다. 특히 백트래킹 알고리즘, 암호 생성, 게임에서의 가능한 움직임을 계산하는 데 많이 사용된다.

-   **재귀 CTE(공통 테이블 식)**

SQL에서 재귀적으로 데이터를 쿼리할 수 있게 해주는 기능이다. 이를 통해 트리 구조와 같이 계층적인 데이터를 쉽게 처리할 수 있다.

**CTE**는 WITH 절을 사용하여 정의되는 임시 결과 집합이다. CTE는 주 쿼리 내에서 사용되며, 가독성을 높이고 쿼리를 더 간단하게 만들 수 있다. 일반적인 CTE는 하나의 쿼리 결과를 포함하지만, 재귀 CTE는 자신을 참조하여 반복적인 처리를 수행할 수 있다.

구조를 살펴보자. 재귀 CTE는 두 부분으로 나뉘어 있다. **기본 쿼리는** 재귀 호출의 시작점이 되는 초기 데이터를 정의한다. **재귀 쿼리**는 기본 쿼리에서 시작하여 자신을 재귀적으로 호출하여 데이터를 반복적으로 생성한다. 재귀 CTE의 기본 구조는 다음과 같다.

```
WITH RECURSIVE cte_name AS (
    -- 기본 쿼리: 재귀의 시작점
    SELECT initial_column1, initial_column2, ...
    FROM some_table
    WHERE condition

    UNION ALL

    -- 재귀 쿼리: 자기 자신을 참조하여 반복
    SELECT next_column1, next_column2, ...
    FROM cte_name
    WHERE another_condition
)
SELECT *
FROM cte_name;
```

작동 방식을 살펴보자.

**초기 쿼리 실행 :** 기본 쿼리가 먼저 실행되어 초기 결과 집합을 생성한다.

**재귀 쿼리 실행 :** 초기 결과를 바탕으로 재귀 쿼리가 실행되어 새로운 결과를 생성한다. 이 과정은 더 이상 결과가 생성되지 않을 때까지 반복된다.

**최종 결과 반환 :** 최종적으로 쿼리의 마지막 SELECT 문을 통해 결과가 반환된다.

예를 통해 다시 알아보자. 계층적인 데이터를 가진 직원 테이블에서 특정 직원의 모든 하위 직원을 찾고 싶다면, 다음과 같은 재귀 CTE를 사용할 수 있다.

```
WITH RECURSIVE employee_hierarchy AS (
    -- 기본 쿼리: 특정 직원을 선택
    SELECT employee_id, name, manager_id
    FROM employees
    WHERE employee_id = 1  -- 예: 직무 ID가 1인 직원

    UNION ALL

    -- 재귀 쿼리: 하위 직원을 찾기
    SELECT e.employee_id, e.name, e.manager_id
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT *
FROM employee_hierarchy;
```

위의 내용을 다시 요약해보겠다. **재귀 CTE**는 SQL 쿼리 내에서 반복적으로 데이터를 처리할 수 있는 강력한 도구이다. 계층적인 구조를 처리하는 데 유용하며, 이해하기 쉽고 가독성이 뛰어난 쿼리를 작성할 수 있게 도와준다. 올바른 사용을 통해 데이터베이스에서 복잡한 계층적 쿼리를 간편하게 수행할 수 있다.

이러한 방식으로 재귀 CTE를 활용하면 다양한 데이터 집합을 쉽게 탐색하고 결과를 효율적으로 처리할 수 있다.