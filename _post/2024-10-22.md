---
title: "[GitHub Blog] TIL 20"

writer: ysooj
categories:
- GitHub Blog
tags: [Blog, jekyll, Github, Git, markdown, TIL]

toc: true
toc_sticky: true

date: 2024-10-22
---

#### **합성곱 신경망 CNN** (Convolutional Neural Network)

이미지와 같은 2차원 데이터를 효율적으로 분석하기 위해 개발된 신경망으로, 주로 합성곱 층, 풀링 층, 완전 연결 층으로 구성한다.

**합성곱 층(Convolutional Layer)**은 입력 이미지에 커널(필터)을 적용해 특징 맵을 생성한다. 커널은 이미지의 일부에서 패턴을 찾아내고 학습하는 역할을 한다.

**풀링 층(Pooling Layer)**은 특징 맵의 크기를 줄이고 핵심적인 특징을 추출한다. 주로 최대 풀링(Max Pooling)과 평균 풀링(Average Pooling)이 사용되며, 최대 풀링은 필터 내에서 가장 큰 값을 선택하여 중요한 정보를 강조하고, 평균 풀링은 필터 내에서 평균 값을 계산하여 정보 손실을 최소화하며 크기를 줄인다. 또한, 플래튼 층(Flatten Layer)은 2차원 특징 맵을 1차원 벡터로 변환하여 완전 연결 층의 입력으로 사용한다.

**완전 연결 층 Fully Connected Layer**은 앞서 추출한 특징을 바탕으로 최종 예측을 수행하는 층이다. CNN이 추출한 정보를 종합해 결론을 도출하는 단계다.

---

#### **순환 신경망 RNN** (Recurrent Neural Network)

시계열 데이터나 순차적인 데이터를 처리하기 위해 고안된 신경망으로, 이전 단계의 정보를 다음 단계로 전달하여 시퀀스 데이터의 패턴을 학습할 수 있다.

**RNN**은 **순환 구조**이다. 입력 데이터와 이전 단계의 은닉 상태를 함께 사용하여 현재 단계의 은닉 상태를 생성한다. 이 은닉 상태는 시퀀스의 정보를 기억하며 다음 단계로 전달한다.

**동작 원리**를 살펴보자. 모든 시간 단계에서 동일한 가중치를 사용하여 시퀀스의 패턴을 학습하며, 순전파(Forward Propagation)와 시간 역전파(BPTT)를 통해 가중치가 학습된다.

RNN은 **장기 의존성 문제(long-term dependency problem)**를 겪을 수 있는데, 이를 해결하기 위해 LSTM과 GRU가 개발되었다.

**LSTM (Long Short-Term Memory)**은 셀 상태(cell state)와 게이트(gate) 구조를 도입해서, 장기 의존성을 효과적으로 학습할 수 있다. 입력 게이트(input gate), 출력 게이트(output gate), 망각 게이트(forget gate)를 사용해 정보를 조절한다.

**GRU (Gated Recurrent Unit)**는 LSTM의 변형으로, 셀 상태 대신 은닉 상태(hidden state)만을 사용해 구조를 단순하게 만든다. 업데이트 게이트(update gate)와 리셋 게이트(reset gate)를 사용해 정보를 조절한다.

이 둘의 **차이점**을 알아보자.

**LSTM**은 셀 상태와 은닉 상태를 둘 다 사용하며, 더 복잡한 게이트 구조를 가진다. **GRU**는 은닉 상태만 사용하며, 더 간단한 게이트 구조를 가진다. 따라서 GRU는 LSTM에 비해 계산 비용이 적고, 학습이 빠를 수 있다.

**RNN**은****1) 데이터 전처리**   **2) 모델 구축**   **3) 모델 학습**    **4) 모델 평가**** 단계를 거쳐 시계열 데이터를 처리한다. 이것의 예로는 주식 가격 예측, 날씨 예측, 텍스트 생성 등이 있다.

---

#### **어텐션 (Attention) 메커니즘**

나열된 정보들인 시퀀스 데이터에서 중요한 부분에 더 많은 가중치를 할당해 정보를 효율적으로 처리하는 기법이다. 주로 시계열 데이터에서 사용되며, 번역, 요약, 질의응답 등 다양한 분야에서 뛰어난 성능을 보인다.

**Self-Attention**은 기존에 위에서 설명한 Attention이다. 그에 반해 **Multi-Attention**은 여러 개의 attention을 병렬로 수행한다. 각각의 헤드, 즉 attention은 서로 다른 정보를 학습하게 되는데, 이를 통해 모델이 다양한 관점에서 데이터를 처리할 수 있게 된다.

우리는 실제로 Attention 코드를 직접 구현할 일은 없을 것이기 때문에 코드를 한 번 훑어보는 정도로 넘어가자.

---

#### **자연어 처리(NLP) 모델**

컴퓨터가 인간의 언어를 이해하고 처리하는 데 사용되는 기계학습 모델 전체를 말한다. 중요한 개념으로는 **워드 임베딩**, **시퀀스 모델링**, **Transformer**와 **BERT**라는 모델이 있다.

**워드 임베딩**은 단어를 고정된 크기의 벡터, 즉 숫자의 나열로 변환해준다. 모든 데이터는 숫자로 처리돼야 결과적으로 컴퓨터가 처리할 수 있기 때문이다. 대표적인 워드 임베딩 기법으로는 **Word2Vec**과 **GloVe**라는 모델이 있다.

**Word2Vec**은 단어를 벡터로 변환하는 두 가지 모델(CBOW와 Skip-gram)을 제공한다. **CBOW**는 주변 단어들의 벡터를 결합해서 중심 단어를 예측하도록 학습하는 모델이다. 반면에 **Skip-gram**은 중심 단어의 벡터로부터 주변 단어를 예측하도록 학습하는 모델이다.

위의 방법 이외의 방법으로는 통계적인 방법을 사용하는 **GloVe**라는 모델이다.  이는 Co-occurrence Matrix(공기행렬)을 사용해 단어 간의 연관성을 학습하고, 이를 바탕으로 단어들을 벡터로 변환할 수 있다.

**시퀀스 모델링**은 순차적인 데이터를 처리하고 예측하는 모델링 기법을 총칭한다. **RNN, LSTM, GRU**와 같은 순환 신경망이 시퀀스 데이터를 잘 처리한다고 알려져 있기 때문에 일반적으로 이런 모델들을 사용하게 된다.

 **Transformer** 모델은 인코더·디코더 구절을 통해, 즉 인코더를 통해 입력 문장을 인코딩하고, 디코더를 통해 출력을 생성한다. 이 과정에서 어텐션 메커니즘이 사용되고, 이는 단어 간의 관계를 학습하는 데 사용되게 된다. 인코더·디코더 어텐션을 통해 입력과 출력을 연결하고, 모델은 데이터의 의미적 유사성을 학습하고, 이를 바탕으로 번역을 진행하게 된다.

**BERT**는 기본적으로 **Transformer** 인코드를 기본으로 한, 사전 학습된 언어모델이다. 여기서 사전 학습 방법은, 언어 모델을 마스킹해서 예측(마스킹 언어 모델)하고, 다음 문장을 예측(다음 문장 예측)하는 기법을 적용해놨다. 그래서 이를 파인튜닝하면, 다양한 목적에 맞춰 사용할 수 있다.

---

### **비전 모델**

비전모델은 대부분 CNN을 기반으로 하는데, 여기에 새로운 기법을 도입해서 성능을 좋게 만드는 일을 한다. 먼저 그 중 ResNet에 대해 알아보자.

#### **ResNet**

기존에 딥러닝은 이름은 딥러닝이지만, 계층을 딥하게 쌓을 수록 기울기 소실 또는 기울기 폭발이라는 현상이 발생했다. **잔차 학습**이라는 개념을 도입함으로써 이 문제를 해결한 것이 ResNet 모델이다. 잔차 학습은 입력과 출력의 차이라고 생각하면 된다. 네트워크가 직접 입력을 학습하는 대신, 잔차를 학습하게 하는 것이다. 이를 통해 깊은 네트워크도 효과적으로 학습할 수 있게 되었다.

#### **VGG**

ResNet 이전에 깊은 층을 사용해서 성능을 올린 대표적인 모델로, 16개 or 19개 층의 레이어를 갖는다. 중요한 특징 중 하나는 CNN에서의 필터를 작은 것(3\*3)을 사용했다는 것이다. 모델의 구조가 매우 단순하고, 다양한 변형이 가능하다.

#### **Inception**

구글에서 만들었으며, 네트워크 대 네트워크라는 개념을 도입했다. 핵심 구성요소는 Inception 블록이다. 이는 다양한 크기의 필터를 동시에 사용해서 입력 데이터로부터 특징을 추출한다. 다양한 필터들을 사용해서 풍부하고 다양한 특징을 학습할 수 있어서 성능이 뛰어났다. 당시 계산량이 문제가 됐는데, 이를 줄이는 기법을 도입함으로써 상대적으로 효율적인 모델이라고 할 수 있다.

#### **YOLO(You Only Look Once)**

객체 탐지 모델이다. 어떤 이미지가 주어졌을 때, 그 내부에 하나하나의 물체를 탐지한다. 위치와 어떤 물체인지를 동시에 예측하는데, 여기서의 특징은 이미지 전체를 한 번에 처리해서 굉장히 빠르게 동작한다는 것이다.

#### **이미지 세그멘테이션(Image Segmentation)**

이미지를 픽셀 단위로 분할하고, 각 픽셀이 어떤 객체 또는 영역에 속하는지 식별하는 기술로, 크게 2가지로 나뉜다. 먼저 **시멘틱 세그멘테이션**으로, 픽셀 단위로 클래스를 분류한다. 두 번째는 **인스턴스 세그멘테이션**으로, 각각의 클래스 내에서도 객체를 구분한다. 이러한 세그멘테이션을 처리하는 주요 모델들은 **FCN, U-NET, Mask R-CNN**이 있다.

---

### **오토인코더**

오토 인코더는 생성형 모델이라기에는 조금 애매하지만, 오토 인코더가 포함되지 않은 생성형 모델은 없다고 한다.

이는 인코더와 디코더 2가지 구조로 이루어졌다. **인코더**는 인풋을 저차원 공간으로 줄인다. 즉, 중요한 특징만 추출한다고 생각하면 된다. **디코더**는 추출된 정보를 바탕으로 원본 데이터를 만들려고 한다.

인코더와 디코더는 정해진 모델이 존재하지 않기 때문에 다양한 변형이 존재한다. 기본 오토인코더를 깊은 레이어로 만든 **딥 오토인코더(Deep Autoencoder),**  데이터의 잠재 공간을 데이터의 평균과 분산으로 표현하는 **변분 오토인코더(VAE : Variation Autoencoder),**  일부러 출력이 희소하도록 제약을 가하는 **희소 오토인코더(Sparse Autoencoder),**  입력 데이터에 인위적으로 노이즈를 가하는 **잡음 제거 오토인코더(Denoising Autoencoder)**가 있다.